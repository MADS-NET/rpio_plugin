/*
  ____  _       _            _             _       
 / ___|(_)_ __ | | __  _ __ | |_   _  __ _(_)_ __  
 \___ \| | '_ \| |/ / | '_ \| | | | |/ _` | | '_ \ 
  ___) | | | | |   <  | |_) | | |_| | (_| | | | | |
 |____/|_|_| |_|_|\_\ | .__/|_|\__,_|\__, |_|_| |_|
                      |_|            |___/         
# A Template for Rpio.pluginPlugin, a Sink Plugin
# Generated by the command: plugin --type sink -d rpio_plugin rpio.plugin
# Hostname: mads-pi
# Current working directory: /home/mads/Devel
# Creation date: 2025-08-26T15:26:29.715+0200
# NOTICE: MADS Version v1.3.3
*/

// Mandatory included headers
#include <sink.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
// other includes as needed here
#include <gpiod.hpp>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "rpio_out"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class RpioPlugin : public Sink<json> {

public:

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    if (input["pins"].is_null() || !input["pins"].is_object()) {
      _error = "Input data must contain a dictionary of pins {\"10\":1}";
      return return_type::error;
    }
    try {
      auto pins = input["pins"];
      gpiod::line line;
      gpiod::line_request req;
      req.consumer = "rpio_out.plugin";
      req.request_type = gpiod::line_request::DIRECTION_OUTPUT;
      int value;
      for (auto &pair : pins.items()) {
        line = _chip.get_line(atoi(pair.key().c_str()));
        value = pair.value().get<int>();
        if (value != 0 && value != 1) {
          _error = "Pin value must be 0 or 1";
          return return_type::error;
        }
        line.request(req);
        line.set_value(value);
        line.release();
      }
    } catch (const std::exception &e) {
      _error = e.what();
      return return_type::error;
    }
    return return_type::success;
  }

  void set_params(void const *params) override { 
    Sink::set_params(params);
    _params["chip_path"] = "/dev/gpiochip0";
    _params.merge_patch(*(json *)params);
    try {
      _chip_path = _params["chip_path"];
    } catch (nlohmann::json::exception &e) {
      _chip_path = "/dev/gpiochip0";
    }
    _chip = gpiod::chip(_chip_path);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    map<string, string> info;
    info["chip_path"] = _chip_path;
    return info;
  };

private:
  // Define the fields that are used to store internal resources
  string _chip_path;
  gpiod::chip _chip;
};



/*
  ____  _             _             _      _                
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __ 
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |   
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|   
                |___/                                      
Enable the class as plugin 
*/
INSTALL_SINK_DRIVER(RpioPlugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  RpioPlugin plugin;
  json input, params;
  
  // Set example values to params
  params["chip_path"] = "/dev/gpiochip0";

  // Set the parameters
  plugin.set_params(&params);

  input["pins"]["10"] = 1;
  input["pins"]["11"] = 0;
  input["pins"]["12"] = 1;

  // Process data
  if (plugin.load_data(input) != return_type::success) {
    cerr << "Error: " << plugin.error() << endl;
    return 1;
  }
  cout << "Data processed successfully" << endl;

  return 0;
}
